!function(global, factory) {    "function" == typeof define && (define.amd || define.cmd) ? define(function() {        return factory(global)    }) : factory(global, true)}(this, function(win, exportsGlobal) {    function invoke(name, data, d) {        win.WeixinJSBridge ? WeixinJSBridge.invoke(name, attachSign(data), function(res) {            wxCallback(name, res, d)        }) : log(name, d)    }    function attach(evt, c, d) {        win.WeixinJSBridge ? WeixinJSBridge.on(evt, function(a) {            d && d.trigger && d.trigger(a), wxCallback(evt, a, c)        }) : d ? log(evt, d) : log(evt, c)    }    function attachSign(data) {        data = data || {};        data.appId = userConfig.appId;        data.verifyAppId = userConfig.appId;        data.verifySignType = "sha1";        data.verifyTimestamp = userConfig.timestamp + "";        data.verifyNonceStr = userConfig.nonceStr;        data.verifySignature = userConfig.signature;        return data;    }    function signWithScope(s, scope) {        return {            scope: scope,            signType: "sha1",            timeStamp: s.timestamp + "",            nonceStr: s.nonceStr,            addrSign: s.addrSign        }    }    function sign(s) {        return {            timeStamp: s.timestamp + "",            nonceStr: s.nonceStr,            "package": s.package,            paySign: s.paySign,            signType: "SHA1"        }    }    function wxCallback(a, res, c) {        var d, e, f;        delete res.err_code;        delete res.err_desc;        delete res.err_detail;        d = res.errMsg;        d || (d = res.err_msg, delete res.err_msg, d = j(a, d, c), res.errMsg = d);        c = c || {};        c._complete && (c._complete(res), delete c._complete);        d = res.errMsg || "";        userConfig.debug && !c.isInnerInvoke && alert(JSON.stringify(res));        e = d.indexOf(":");        f = d.substring(e + 1);        switch (f) {            case "ok":                c.success && c.success(res);                break;            case "cancel":                c.cancel && c.cancel(res);                break;            default:                c.fail && c.fail(res)        }        c.complete && c.complete(res)    }    function j(a, b) {        var d, e, f, g;        if (b) {            switch (d = b.indexOf(":"), a) {                case bridgeNativeMap.config:                    e = "config";                    break;                case bridgeNativeMap.openProductSpecificView:                    e = "openProductSpecificView";                    break;                default:                    e = b.substring(0, d), e = e.replace(/_/g, " "), e = e.replace(/\b\w+\b/g, function(a) {                        return a.substring(0, 1).toUpperCase() + a.substring(1)                    }), e = e.substring(0, 1).toLowerCase() + e.substring(1), e = e.replace(/ /g, ""), -1 != e.indexOf("Wcpay") && (e = e.replace("Wcpay", "WCPay")), f = bridgeJSMap[e], f && (e = f)            }            g = b.substring(d + 1), "confirm" == g && (g = "ok"), -1 != g.indexOf("failed_") && (g = g.substring(7)), -1 != g.indexOf("fail_") && (g = g.substring(5)), g = g.replace(/_/g, " "), g = g.toLowerCase(), ("access denied" == g || "no permission to execute" == g) && (g = "permission denied"), "config" == e && "function not exist" == g && (g = "ok"), b = e + ":" + g        }        return b    }    function k(apiList) {        var i, len, api, e;        if (apiList) {            for (i = 0, len = apiList.length; len > i; ++i) api = apiList[i], e = bridgeNativeMap[api], e && (apiList[i] = e);            return apiList        }    }    function log(a, b) {        if (userConfig.debug && !b.isInnerInvoke) {            var c = bridgeJSMap[a];            c && (a = c), b && b._complete && delete b._complete, console.log('"' + a + '",', b || "")        }    }    function sendBeacon() {        if (!("6.0.2" > wechatVersion)) {            var beacon = new Image;            A.appId = userConfig.appId;            A.initTime = timing.initEndTime - timing.initStartTime;            A.preVerifyTime = timing.preVerifyEndTime - timing.preVerifyStartTime;            jWeixin.getNetworkType({                isInnerInvoke: !0,                success: function(res) {                    A.networkType = res.networkType;                    var src = "https://open.weixin.qq.com/sdk/report?v=" + A.version + "&o=" + A.isPreVerifyOk + "&s=" + A.systemType + "&c=" + A.clientVersion + "&a=" + A.appId + "&n=" + A.networkType + "&i=" + A.initTime + "&p=" + A.preVerifyTime + "&u=" + A.url;                    beacon.src = src                }            })        }    }    function now() {        return (new Date).getTime()    }    function _WeixinJSBridgeReady(fn) {        isWechat && (win.WeixinJSBridge ? fn() : doc.addEventListener && doc.addEventListener("WeixinJSBridgeReady", fn, false))    }    function initInvoke() {        jWeixin.invoke || (jWeixin.invoke = function(b, c, d) {            win.WeixinJSBridge && WeixinJSBridge.invoke(b, verifySign(c), d)        }, jWeixin.on = function(b, c) {            win.WeixinJSBridge && WeixinJSBridge.on(b, c)        })    }    var bridgeNativeMap, bridgeJSMap, doc, title, userAgent, isWechat, isAndroid, isIOS, wechatVersion, timing, A, userConfig, cbQueuesSet, wxRet, jWeixin;    if (win.jWeixin) return;    bridgeNativeMap = {        config: "preVerifyJSAPI",        onMenuShareTimeline: "menu:share:timeline",        onMenuShareAppMessage: "menu:share:appmessage",        onMenuShareQQ: "menu:share:qq",        onMenuShareWeibo: "menu:share:weiboApp",        previewImage: "imagePreview",        getLocation: "geoLocation",        openProductSpecificView: "openProductViewWithPid",        addCard: "batchAddCard",        openCard: "batchViewCard",        chooseWXPay: "getBrandWCPayRequest"    };    bridgeJSMap = function() {        var key, _map = {};        for (key in bridgeNativeMap) _map[bridgeNativeMap[key]] = key;        return _map;    }();    doc = win.document;    title = doc.title;    userAgent = navigator.userAgent.toLowerCase();    isWechat = -1 != userAgent.indexOf("micromessenger");    isAndroid = -1 != userAgent.indexOf("android");    isIOS = -1 != userAgent.indexOf("iphone") || -1 != userAgent.indexOf("ipad");    wechatVersion = function() {        var a = userAgent.match(/micromessenger\/(\d+\.\d+\.\d+)/) || userAgent.match(/micromessenger\/(\d+\.\d+)/);        return a ? a[1] : ""    }();    timing = {        initStartTime: now(),        initEndTime: 0,        preVerifyStartTime: 0,        preVerifyEndTime: 0    };    A = {        version: 1,        appId: "",        initTime: 0,        preVerifyTime: 0,        networkType: "",        isPreVerifyOk: 1,        systemType: isIOS ? 1 : isAndroid ? 2 : -1,        clientVersion: wechatVersion,        url: encodeURIComponent(location.href)    };    userConfig = {};    cbQueuesSet = {        _completes: []    };    wxRet = {        state: 0,        res: {}    };    _WeixinJSBridgeReady(function() {        timing.initEndTime = now()    });    jWeixin = {        config: function(_config) {            userConfig = _config;            log("config", _config);            _WeixinJSBridgeReady(function() {                invoke(bridgeNativeMap.config, {                    verifyJsApiList: k(userConfig.jsApiList)                }, function() {                    cbQueuesSet._complete = function(a) {                        timing.preVerifyEndTime = now(), wxRet.state = 1, wxRet.res = a                    }, cbQueuesSet.success = function() {                        A.isPreVerifyOk = 0                    }, cbQueuesSet.fail = function(a) {                        cbQueuesSet._fail ? cbQueuesSet._fail(a) : wxRet.state = -1                    };                    var a = cbQueuesSet._completes;                    a.push(function() {                        userConfig.debug || sendBeacon()                    });                    cbQueuesSet.complete = function(b) {                        for (var c = 0, d = a.length; d > c; ++c) a[c](b);                        cbQueuesSet._completes = []                    };                    return cbQueuesSet;                }());                timing.preVerifyStartTime = now();            });            userConfig.beta && initInvoke();        },        ready: function(fn) {            0 != wxRet.state ? fn() : (cbQueuesSet._completes.push(fn), !isWechat && userConfig.debug && fn())        },        error: function(fn) {            "6.0.2" > wechatVersion || (-1 == wxRet.state ? fn(wxRet.res) : cbQueuesSet._fail = fn)        },        checkJsApi: function(obj) {            var b = function(a) {                var c, d, b = a.checkResult;                for (c in b) d = bridgeJSMap[c], d && (b[d] = b[c], delete b[c]);                return a            };            invoke("checkJsApi", {                jsApiList: k(obj.jsApiList)            }, function() {                obj._complete = function(a) {                    if (isAndroid) {                        var c = a.checkResult;                        c && (a.checkResult = JSON.parse(c))                    }                    a = b(a)                };                return obj;            }())        },        /**         * 获取“分享到朋友圈”按钮点击状态及自定义分享内容接口         * @method         * @param {Object} obj         * @param {string} obj.title - 分享标题         * @param {string} obj.link - 分享链接         * @param {string} obj.imgUrl - 分享图标         * @param {Function} [obj.success] - 用户确认分享后执行的回调函数         * @param {Function} [obj.cancel] - 用户取消分享后执行的回调函数         */        onMenuShareTimeline: function(obj) {            attach(bridgeNativeMap.onMenuShareTimeline, {                complete: function() {                    invoke("shareTimeline", {                        title: obj.title || title,                        desc: obj.title || title,                        img_url: obj.imgUrl,                        link: obj.link || location.href                    }, obj)                }            }, obj)        },        /**         * 获取“分享给朋友”按钮点击状态及自定义分享内容接口         * @method         * @param {Object} obj         * @param {string} obj.title - 分享标题         * @param {string} obj.desc - 分享描述         * @param {string} obj.link - 分享链接         * @param {string} obj.imgUrl - 分享图标         * @param {string} [obj.dataUrl="link"] - 分享类型，music、video 或 link         * @param {Function} [obj.success] - 用户确认分享后执行的回调函数         * @param {Function} [obj.cancel] - 用户取消分享后执行的回调函数         */        onMenuShareAppMessage: function(obj) {            attach(bridgeNativeMap.onMenuShareAppMessage, {                complete: function() {                    invoke("sendAppMessage", {                        title: obj.title || title,                        desc: obj.desc || "",                        link: obj.link || location.href,                        img_url: obj.imgUrl,                        type: obj.type || "link",                        data_url: obj.dataUrl || ""                    }, obj)                }            }, obj)        },        /**         * 获取“分享到QQ”按钮点击状态及自定义分享内容接口         * @method         * @param {Object} obj         * @param {string} obj.title - 分享标题         * @param {string} obj.desc - 分享描述         * @param {string} obj.link - 分享链接         * @param {string} obj.imgUrl - 分享图标         * @param {Function} [obj.success] - 用户确认分享后执行的回调函数         * @param {Function} [obj.cancel] - 用户取消分享后执行的回调函数         */        onMenuShareQQ: function(obj) {            attach(bridgeNativeMap.onMenuShareQQ, {                complete: function() {                    invoke("shareQQ", {                        title: obj.title || title,                        desc: obj.desc || "",                        img_url: obj.imgUrl,                        link: obj.link || location.href                    }, obj)                }            }, obj)        },        /**         * 获取“分享到腾讯微博”按钮点击状态及自定义分享内容接口         * @method         * @param {Object} obj         * @param {string} obj.title - 分享标题         * @param {string} obj.desc - 分享描述         * @param {string} obj.link - 分享链接         * @param {string} obj.imgUrl - 分享图标         * @param {Function} [obj.success] - 用户确认分享后执行的回调函数         * @param {Function} [obj.cancel] - 用户取消分享后执行的回调函数         */        onMenuShareWeibo: function(obj) {            attach(bridgeNativeMap.onMenuShareWeibo, {                complete: function() {                    invoke("shareWeiboApp", {                        title: obj.title || title,                        desc: obj.desc || "",                        img_url: obj.imgUrl,                        link: obj.link || location.href                    }, obj)                }            }, obj)        },        /**         * 开始录音接口         */        startRecord: function(obj) {            invoke("startRecord", {}, obj)        },        /**         * 停止录音接口         * @param {Object} [obj]         * @param {Function} [obj.success]         */        stopRecord: function(obj) {            invoke("stopRecord", {}, obj)        },        /**         * 监听录音自动停止接口         * @param {Object} [obj]         * @param {Function} [obj.complete]          *   录音时间超过一分钟没有停止的时候会执行 complete 回调         */        onVoiceRecordEnd: function(obj) {            attach("onVoiceRecordEnd", obj)        },        /**         * 播放语音接口         * @param {Object} obj         * @param {string} obj.localId         *   需要播放的音频的本地 ID，由 stopRecord 接口获得         */        playVoice: function(obj) {            invoke("playVoice", {                localId: obj.localId            }, obj)        },        /**         * 暂停播放接口         * @param {Object} obj         * @param {string} obj.localId         *   需要暂停的音频的本地 ID，由 stopRecord 接口获得         */        pauseVoice: function(obj) {            invoke("pauseVoice", {                localId: obj.localId            }, obj)        },        /**         * 停止播放接口         * @param {Object} obj         * @param {string} obj.localId         *   需要停止的音频的本地 ID，由 stopRecord 接口获得         */        stopVoice: function(obj) {            invoke("stopVoice", {                localId: obj.localId            }, obj)        },        /**         * 监听语音播放完毕接口         * @param {Object} obj         * @param {string} obj.serverId         *   需要下载的音频的服务器端 ID，由 uploadVoice 接口获得         * @param {Function} obj.success         */        onVoicePlayEnd: function(obj) {            attach("onVoicePlayEnd", obj)        },        /**         * 上传语音接口         * @param {Object} obj         * @param {string} obj.localId         *   需要上传的音频的本地 ID，由 stopRecord 接口获得         * @param {number} [obj.isShowProgressTips=1]         *   默认为 1，显示进度提示         * @param {Function} obj.success         */        uploadVoice: function(obj) {            invoke("uploadVoice", {                localId: obj.localId,                isShowProgressTips: obj.isShowProgressTips || 1            }, obj)        },        /**         * 下载语音接口         * @param {Object} obj         * @param {string} obj.serverId         *   需要下载的音频的服务器端 ID，由 uploadVoice 接口获得         * @param {number} [obj.isShowProgressTips=1]         *   默认为 1，显示进度提示         * @param {Function} obj.success         */        downloadVoice: function(obj) {            invoke("downloadVoice", {                serverId: obj.serverId,                isShowProgressTips: obj.isShowProgressTips || 1            }, obj)        },        /**         * 识别音频并返回识别结果接口         * @param {Object} obj         * @param {string} obj.localId         *   需要识别的音频的本地 Id，由录音相关接口获得         * @param {number} [obj.isShowProgressTips=1]         *   默认为 1，显示进度提示         * @param {Function} obj.success         */        translateVoice: function(obj) {            invoke("translateVoice", {                localId: obj.localId,                isShowProgressTips: obj.isShowProgressTips || 1            }, obj)        },        /**         * 拍照或从手机相册中选图接口         * @param {Object} obj         * @param {Function} obj.success         */        chooseImage: function(obj) {            invoke("chooseImage", {                scene: "1|2"            }, function() {                obj._complete = function(res) {                    if (isAndroid) {                        var ids = res.localIds;                        ids && (res.localIds = JSON.parse(ids))                    }                };                return obj;            }())        },        /**         * 预览图片接口         * @param {Object} obj         * @param {string} obj.current - 当前显示的图片链接         * @param {string[]} obj.urls - 需要预览的图片链接列表         */        previewImage: function(obj) {            invoke(bridgeNativeMap.previewImage, {                current: obj.current,                urls: obj.urls            }, obj)        },        /**         * 上传图片接口         * @param {Object} obj         * @param {string} obj.localId         *   需要上传的图片的本地 ID，由 chooseImage 接口获得         * @param {number} [obj.isShowProgressTips=1]         *   默认为 1，显示进度提示         */        uploadImage: function(obj) {            invoke("uploadImage", {                localId: obj.localId,                isShowProgressTips: obj.isShowProgressTips || 1            }, obj)        },        /**         * 下载图片接口         * @param {Object} obj         * @param {string} obj.serverId         *   需要下载的图片的服务器端 ID，由 uploadImage 接口获得         * @param {number} [obj.isShowProgressTips=1]         *   默认为 1，显示进度提示         */        downloadImage: function(obj) {            invoke("downloadImage", {                serverId: obj.serverId,                isShowProgressTips: obj.isShowProgressTips || 1            }, obj)        },        /**         * 获取网络状态接口         */        getNetworkType: function(obj) {            var _getNextworkType = function(res) {                var subtype, idx, type, errMsg = res.errMsg;                res.errMsg = "getNetworkType:ok";                subtype = res.subtype;                delete res.subtype;                if (subtype) res.networkType = subtype;                else switch (idx = errMsg.indexOf(":"), type = errMsg.substring(idx + 1)) {                    case "fail":                    case "permission denied":                    case "localparameters":                        res.errMsg = "getNetworkType:fail";                        break;                    default:                        res.networkType = type                }                return res            };            invoke("getNetworkType", {}, function() {                obj._complete = function(res) {                    res = _getNextworkType(res)                };                return obj;            }())        },        /**         * 使用微信内置地图查看位置接口         * @param {Object} obj         * @param {number} ojb.latitude - 纬度，浮点数，范围为90 ~ -90         * @param {number} obj.longitude - 经度，浮点数，范围为180 ~ -180         * @param {string} [obj.name] - 位置名         * @param {string} [obj.address] - 地址详情说明         * @param {number} [obj.scale=28]         *   地图缩放级别,整形值,范围从1~28。默认为最大         * @param {string} [obj.infoUrl]         *   在查看位置界面底部显示的超链接,可点击跳转         */        openLocation: function(obj) {            invoke("openLocation", {                latitude: obj.latitude,                longitude: obj.longitude,                name: obj.name || "",                address: obj.address || "",                scale: obj.scale || 28,                infoUrl: obj.infoUrl || ""            }, obj)        },        /**         * 获取地理位置接口         * @param {Object} obj         * @param {number} [ojb.timestamp=0]         *   位置签名时间戳，仅当需要兼容6.0.2版本之前时提供         * @param {string} [obj.nonceStr]         *   位置签名随机串，仅当需要兼容6.0.2版本之前时提供         * @param {string} [obj.addrSign]         *   位置签名，仅当需要兼容6.0.2版本之前时提供，详见[附录4]{@link http://tinyurl.com/wx-js-sdk-a4}         */        getLocation: function(obj) {            invoke(bridgeNativeMap.getLocation, signWithScope(obj, "jsapi_location"), obj)        },        /**         * 隐藏右上角菜单接口         * @param {Object} [obj]         */        hideOptionMenu: function(obj) {            invoke("hideOptionMenu", {}, obj)        },        /**         * 显示右上角菜单接口         * @param {Object} [obj]         */        showOptionMenu: function(obj) {            invoke("showOptionMenu", {}, obj)        },        /**         * 关闭当前网页窗口接口         * @param {Object} [obj]         * @param {number} [obj.immediateClose=0]         */        closeWindow: function(obj) {            invoke("closeWindow", {                immediate_close: obj && obj.immediateClose || 0            }, obj)        },        /**         * 批量隐藏功能按钮接口         * @param {Object} obj         * @param {string[]} [obj.menuList=[]] - 要隐藏的菜单项，所有menu项见[附录3]{@link http://tinyurl.com/wx-js-sdk-a3}         */        hideMenuItems: function(obj) {            invoke("hideMenuItems", {                menuList: obj.menuList            }, obj)        },        /**         * 批量显示功能按钮接口         * @param {Object} obj         * @param {string[]} [obj.menuList=[]] - 要显示的菜单项，所有menu项见[附录3]{@link http://tinyurl.com/wx-js-sdk-a3}         */        showMenuItems: function(obj) {            invoke("showMenuItems", {                menuList: obj.menuList            }, obj)        },        /**         * 隐藏所有非基础按钮接口         * @param {Object} [obj]         */        hideAllNonBaseMenuItem: function(obj) {            invoke("hideAllNonBaseMenuItem", {}, obj)        },        /**         * 显示所有功能按钮接口         * @param {Object} [obj]         */        showAllNonBaseMenuItem: function(obj) {            invoke("showAllNonBaseMenuItem", {}, obj)        },        /**         * 调起微信扫一扫接口         * @param {Object} obj         * @param {string} [obj.desc]         * @param {string} [obj.needResult=0]         *   默认为 0，扫描结果由微信处理，1 则直接返回扫描结果         * @param {string[]} [obj.scanType=["qrCode", "barCode"]]         *   可以指定扫二维码还是一维码，默认二者都有         */        scanQRCode: function(obj) {            invoke("scanQRCode", {                desc: obj.desc,                needResult: obj.needResult || 0,                scanType: obj.scanType || ["qrCode", "barCode"]            }, obj)        },        /**         * @param {string} obj         * @param {string} obj.productId - 商品id         * @param {number} [obj.viewType=0]         *   0：普通商品详情页         *   1：扫一扫商品详情页         *   2：小店商品详情页         */        openProductSpecificView: function(obj) {            invoke(bridgeNativeMap.openProductSpecificView, {                pid: obj.productId,                view_type: obj.viewType || 0            }, obj)        },        /**         * @typedef {Object} Card         * @property {string} cardId         * @property {string} cardExt         * @property {string} code         */        /**         * 批量添加卡券接口         * @param {Object} obj         * @param {Card[]} obj.cardList - 需要添加的卡券列表         */        addCard: function(obj) {            var i, len, temp_card, card, cardList = obj.cardList,                card_list = [];            for (i = 0, len = cardList.length; len > i; ++i) {                temp_card = cardList[i];                card = {                    card_id: temp_card.cardId,                    card_ext: temp_card.cardExt                };                card_list.push(card);            }            invoke(bridgeNativeMap.addCard, {                card_list: card_list            }, function() {                obj._complete = function(res) {                    var i, len, card, cardList = res.card_list;                    if (cardList) {                        for (cardList = JSON.parse(cardList), i = 0, len = cardList.length; len > i; ++i) {                            card = cardList[i];                            card.cardId = card.card_id;                            card.cardExt = card.card_ext;                            card.isSuccess = card.is_succ ? !0 : !1;                            delete card.card_id;                            delete card.card_ext;                            delete card.is_succ;                        }                        res.cardList = cardList, delete res.card_list                    }                };                return obj;            }())        },        /**         * 调起适用于门店的卡券列表并获取用户选择列表         * @param {Object} obj         * @param {string} [obj.shopId] - 门店Id         * @param {string} [obj.cardType] - 卡券类型         * @param {string} [obj.cardId] - 卡券Id         * @param {number} obj.timeStamp - 卡券签名时间戳         * @param {string} obj.nonceStr - 卡券签名随机串         * @param {string} obj.cardSign - 卡券签名，详见[附录6]{@link http://tinyurl.com/wx-js-sdk-a6}         */        chooseCard: function(obj) {            invoke("chooseCard", {                app_id: userConfig.appId,                location_id: obj.shopId || "",                sign_type: "SHA1",                card_id: obj.cardId || "",                card_type: obj.cardType || "",                card_sign: obj.cardSign,                time_stamp: obj.timestamp + "",                nonce_str: obj.nonceStr            }, function() {                obj._complete = function(res) {                    res.cardList = res.choose_card_info;                    delete res.choose_card_info;                };                return obj;            }())        },        /**         * 查看微信卡包中的卡券接口         * @param {Object} obj         * @param {Card[]} obj.cardList - 需要打开的卡券列表         */        openCard: function(obj) {            var i, len, temp_card, card, cardList = obj.cardList,                card_list = [];            for (i = 0, len = cardList.length; len > i; ++i) {                temp_card = cardList[i];                card = {                    card_id: temp_card.cardId,                    code: temp_card.code                };                card_list.push(card);            }            invoke(bridgeNativeMap.openCard, {                card_list: card_list            }, obj)        },        /**         * 发起一个微信支付请求         * @param {Object} obj         * @param {number} obj.timestamp - 支付签名时间戳         * @param {string} obj.nonceStr - 支付签名随机串         * @param {string} obj.package - 订单详情扩展字符串，详见[附录5]{@link http://tinyurl.com/wx-js-sdk-a5}         * @param {string} obj.paySign - 支付签名，详见[附录5]{@link http://tinyurl.com/wx-js-sdk-a5}         */        chooseWXPay: function(obj) {            invoke(bridgeNativeMap.chooseWXPay, sign(obj), obj)        }    };    exportsGlobal && (win.wx = win.jWeixin = jWeixin);    return jWeixin;});